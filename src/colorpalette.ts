import chroma from 'chroma-js';
import colorNamer from 'color-namer';

type ColorSet = {
    label: string;
    baseColor: string;
    baseStep: number;
    palette: Record<string, number>;
};

/**
 * Represents a color palette generator.
 */
class ColorPalette {
    private set: ColorSet;

    constructor(baseColor: string, baseStep: number = 700) {
        const namedColor: String = colorNamer(baseColor.replace('#', ''), { pick: ['ntc'] })?.ntc[0]?.name ?? 'Primary';

        this.set = {
            label: namedColor,
            baseColor: baseColor,
            baseStep: parseInt(baseStep),
            palette: {},
        };
    }

    /**
     * Generates a lightness scale based on a given base lightness value.
     *
     * @param baseLightness - The base lightness value used to generate the scale.
     * @returns An array of lightness values forming the scale.
     * @throws {Error} If the baseStep value is invalid.
     */
    private generateLightnessScale(baseLightness: number): number[] {
        const steps = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        const lightnessScale: number[] = [];

        // Calculate range for lightness adjustment
        const minLightness = Math.max(baseLightness - 0.4, 0.01); // Avoiding pure black
        const maxLightness = Math.min(baseLightness + 0.4, 0.99); // Avoiding pure white

        const stepIndex = steps.indexOf(this.set.baseStep);
        if (stepIndex === -1) {
            throw new Error(`Invalid baseStep value. Valid steps are ${steps.join(', ')}, you supplied ${this.set.baseStep}`);
        }

        const segmentsAbove = steps.length - stepIndex - 1;
        const segmentsBelow = stepIndex;

        // Distribute lightness values above and below the base lightness
        for (let i = -segmentsBelow; i <= segmentsAbove; i++) {
            const lightness = baseLightness + (i * (maxLightness - minLightness)) / (segmentsAbove + segmentsBelow);
            lightnessScale.push(Math.max(Math.min(lightness, 0.99), 0.01)); // Clamp between 0.05 and 0.95
        }

        return lightnessScale.reverse(); // Reverse the scale to invert the order
    }

    /**
     * Generates a color based on the given step value.
     *
     * @param {number} step - The step value to determine the color.
     * @throws {Error} If the step value is invalid.
     * @return {string} The generated color in hexadecimal format.
     */
    public generateColor(step: number): string {
        const steps = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        const stepIndex = steps.indexOf(step);
        if (stepIndex === -1) {
            throw new Error(`Invalid step value. Valid steps are ${steps.join(', ')}`);
        }

        // Convert base color to HSL and get base lightness
        const hslColor = chroma(this.set.baseColor).hsl();
        const baseLightness = hslColor[2];

        // Generate lightness scale based on base step
        const lightnessScale = this.generateLightnessScale(baseLightness);

        // Adjust lightness to match the step
        hslColor[2] = lightnessScale[stepIndex];

        // Convert the HSL color back to hex
        return chroma.hsl(hslColor).hex();
    }

    /**
     * Generates a color palette with predefined steps.
     * Each step in the palette is represented by a corresponding color generated by the generateColor method.
     *
     * @returns {Record<string, string>} - The generated color palette, where each key represents a step and its corresponding value represents the color.
     */
    public generatePalette(): Record<string, string> {
        const steps = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        const palette: Record<string, string> = {};
        for (const step of steps) {
            palette[step] = this.generateColor(step);
        }
        return palette;
    }

    /**
     * Generates a ColorSet by generating a palette using the generatePalette method.
     *
     * @returns {ColorSet} The generated ColorSet.
     */
    public generateSet(): ColorSet {
        this.set.palette = this.generatePalette();
        return this.set;
    }
}

export { ColorSet, ColorPalette };
